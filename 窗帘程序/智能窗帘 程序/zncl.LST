C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE ZNCL
OBJECT MODULE PLACED IN zncl.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE zncl.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********51单片机智能窗帘设计*********/
   2          /*************JJ电子直营店*************/
   3          /***************原创设计***************/
   4          
   5          #include <REGX52.H>                             //头文件
   6          #define uchar unsigned char
   7          #define uint unsigned int
   8          
   9          #define CS      P3_0            //ADC0804 CS端口
  10          #define RD      P3_1            //ADC0804 RD端口
  11          #define WR      P3_2            //ADC0804 WR端口
  12          #define g_kz    P2_5    //数码管个位控制
  13          #define s_kz    P2_4    //数码管十位控制
  14          #define b_kz    P2_3    //数码管百位控制
  15          #define q_kz    P2_2    //码管千位控制
  16          #define SMG_XS  P0              //数码管显示端口
  17          #define AD_data P1              //ADC0804输出端口
  18          #define Up              P2_1    //上限限位开关端口
  19          #define Down    P2_0    //下限限位开关端口
  20          #define Key1    P3_3    //手动/自动切换 按键
  21          #define Key2    P3_4    //定时/光控功能切换 按键
  22          #define Key3    P3_5    //设置 按键
  23          #define Key4    P3_6    //加 按键 (手动模式:打开窗帘 定时模式：定时打开窗帘)
  24          #define Key5    P3_7    //减 按键 (手动模式:关闭窗帘 定时模式：定时关闭窗帘)
  25          
  26          #define IA              P2_7    //直流电机控制端口
  27          #define IB              P2_6    //直流电机控制端口
  28          
  29          int adval;              //ADC 输出变量
  30          int j;                  //定义循环变量 i j
  31          uchar flag=0;   //显示标志位(0:正常显示 1:上限光照度设置(调时) 2:下限光照度设置(调分)                            
  32          bit flag_gd=0;  //光控/定时标志位(0:当前光照度 1:定时时间 )     
  33          bit ms=0;               //模式(0:手动模式 1:自动模式)
  34          bit move=0;             //定时时间到标志位(0:时间未到 1:时间到)
  35          bit OFF_ON=0;   //电机正反转标志位,表示窗帘打开或关闭(0:窗帘关闭 1:窗帘打开)
  36          bit Time_OFF_ON=0;//定时时间到执行窗帘打开或关闭(0:定时关闭窗帘 1:定时打开窗帘)
  37          
  38          char hour=12,min=0;sec=0; //定义时间 “时 分 秒”变量 上电默认12.00.00
  39          char num=0;     //时间基数
  40          uint H_GM=240;  //定义上限光敏度设置变量，上电默认200
  41          uint L_GM=100;  //定义下限光敏度设置变量，上电默认100
  42          uchar t=1;              //数码管动态扫描延时参数
  43                          
  44          uchar code table[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90}; 
  45          //数码管显示数组      0    1    2    3    4    5    6    7    8    9
  46          
  47          void delay(uint time)           //延时函数
  48          {
  49   1              uint x,y;                       //定义临时变量 x y
  50   1              for(x=time;x>0;x--)
  51   1              for(y=110;y>0;y--);     //空操作
  52   1      }
  53          
  54          void  Time_init()               //定时器初始化
  55          {
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 2   

  56   1              EA=1;
  57   1              TMOD=0x11;
  58   1      
  59   1              /*定时器0初始化(产生PWM控制电机转速)*/  
  60   1              TH0=0xf8;       //定时2ms
  61   1              TL0=0xcc;
  62   1              ET0=1;          //使能T0中断
  63   1              TR0=0;          //先不启动定时器0
  64   1              /*定时器1初始化(产生50ms定时时间)*/
  65   1              TH1=0x4c;               //50ms
  66   1              TL1=0x00;
  67   1              ET1=1;
  68   1              TR1=0;          //先不启动定时器1       
  69   1      }
  70          
  71          void Key_cl()
  72          {
  73   1              static bit keybuf1=1;   //Key1值暂存,临时保存按键扫描值
  74   1              static bit backup1=1;   //Key1值备份,保存前一次的扫描值
  75   1              static bit keybuf2=1;   //Key2值暂存,临时保存按键扫描值 
  76   1              static bit backup2=1;   //Key2值备份,保存前一次的扫描值
  77   1              static bit keybuf3=1;   //Key3值暂存,临时保存按键扫描值
  78   1              static bit backup3=1;   //Key3值备份,保存前一次的扫描值
  79   1              static bit keybuf4=1;   //Key4值暂存,临时保存按键扫描值
  80   1              static bit backup4=1;   //Key4值备份,保存前一次的扫描值
  81   1              static bit keybuf5=1;   //Key5值暂存,临时保存按键扫描值
  82   1              static bit backup5=1;   //Key5值备份,保存前一次的扫描值
  83   1              keybuf1=Key1;                   //把Key1当前值扫描值暂存
  84   1              if(keybuf1!=backup1)    //Key1当前值与前次值不相等,说明Key1按键有动作
  85   1              {
  86   2                      delay(1);                       //延时去抖
  87   2                      if(keybuf1==Key1)       //判断Key1扫描值有没有发生变化,即按键抖动
  88   2                      {
  89   3                              if(backup1==1)  //Key1按键按下有效
  90   3                              {
  91   4                                      move=0;         //重置时间标志位为0(时间未到)
  92   4                                      TR0=0;          //关闭定时器0
  93   4                                      ms=~ms;         // 模式取反
  94   4                                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;//关闭数码管显示
  95   4                                      IA=0;IB=0;      //窗帘停止      
  96   4                              }
  97   3                              backup1=keybuf1; //更新备份Key1当前值,以备进行下次比较
  98   3                      }
  99   2              }
 100   1              if(ms==0)                       //手动模式下
 101   1              {
 102   2                      if(Key4==0)             //当打开窗帘按键 按下
 103   2                      {
 104   3                              delay(10);      //延时去抖
 105   3                              if(Key4==0)     //再判断按键是否按下
 106   3                              {
 107   4                                      move=0;                         //重置时间标志位为0(时间未到)
 108   4                                      OFF_ON=1;                       //窗帘打开
 109   4                                      TR0=1;                          //开启定时器0
 110   4                                      SMG_XS=table[1];        //数码管显示"1"
 111   4                                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位显示
 112   4                                      while(Key4==0); //等待按键松开
 113   4                                      TR0=0;                  //关闭定时器0
 114   4                                      IA=0;IB=0;              //窗帘停止
 115   4                                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //关闭数码管    
 116   4                              }
 117   3                      }
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 3   

 118   2                      if(Key5==0)             //当关闭窗帘按键 按下
 119   2                      {
 120   3                              delay(10);      //延时去抖      
 121   3                              if(Key5==0)     //再判断按键是否按下
 122   3                              {
 123   4                                      move=0;                         //重置时间标志位为0(时间未到)
 124   4                                      OFF_ON=0;                       //窗帘关闭
 125   4                                      TR0=1;                          //开启定时器0
 126   4                                      SMG_XS=table[0];        //数码管显示"0"
 127   4                                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位显示
 128   4                                      while(Key5==0); //等待按键松开
 129   4                                      TR0=0;                  //关闭定时器0
 130   4                                      IA=0;IB=0;      //窗帘停止      
 131   4                                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //关闭数码管
 132   4                              }
 133   3                      }               
 134   2              }
 135   1              else            //自动模式下
 136   1              {
 137   2                      keybuf2=Key2;                   //把Key2当前值扫描值暂存
 138   2                      if(keybuf2!=backup2)    //Key2当前值与前次值不相等,说明Key2按键有动作
 139   2                      {
 140   3                              delay(1);                       //延时去抖
 141   3                              if(keybuf2==Key2)       //判断Key2扫描值有没有发生变化,即按键抖动
 142   3                              {
 143   4                                      if(backup2==1)  //Key2按键按下有效
 144   4                                      {       
 145   5                                              move=0;         //重置时间标志位为0(时间未到)
 146   5                                              flag_gd=~flag_gd; //光控/定时标志位取反(0:当前光照度 1:定时时间 )                                                               
 147   5                                      }
 148   4                                      backup2=keybuf2; //更新备份Key2当前值,以备进行下次比较
 149   4                              }
 150   3                      }
 151   2                      keybuf3=Key3;           //把Key3当前值扫描值暂存                        
 152   2                      if(keybuf3!=backup3)//Key3当前值与前次值不相等,说明Key3按键有动作
 153   2                      {
 154   3                              delay(1);               //延时去抖
 155   3                              if(keybuf3==Key3)       //判断Key3扫描值有没有发生变化,即按键抖动       
 156   3                              {
 157   4                                      if(backup3==1)  //Key3按键按下有效
 158   4                                      {
 159   5                                              move=0;         //重置时间标志位为0(时间未到)
 160   5                                              TR0=0;          //关闭定时器0
 161   5                                              flag++;
 162   5                                              if(flag==3) {flag=0;}   //让flag保持在0-2之间
 163   5                                      }
 164   4                                      backup3=keybuf3;//更新备份Key3当前值,以备进行下次比较
 165   4                              }
 166   3                      }
 167   2                      if(flag==1)                             //允许上限光照度设置(调时)                      
 168   2                      {
 169   3                              keybuf4=Key4;           //把Key4当前值扫描值暂存
 170   3                              if(keybuf4!=backup4)//Key4当前值与前次值不相等,说明Key4按键有动作
 171   3                              {
 172   4                                      delay(1);               //延时去抖
 173   4                                      if(keybuf4==Key4)       //判断Key4扫描值有没有发生变化,即按键抖动       
 174   4                                      {
 175   5                                              if(backup4==1)  //Key4按键按下有效
 176   5                                              {
 177   6                                                      if(flag_gd==0)  //光照度设置允许        
 178   6                                                      {
 179   7                                                              H_GM++;         //设置上限光敏度加1
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 4   

 180   7                                                              if(H_GM==256) {H_GM=0;} //让光敏度在0-255之间   
 181   7                                                      }
 182   6                                                      else                    //否则 调时允许
 183   6                                                      {
 184   7                                                              hour++;         //时加1
 185   7                                                              if(hour==24) {hour=0;}  //hour保持在0-23之间            
 186   7                                                      }               
 187   6                                              }
 188   5                                              backup4=keybuf4;//更新备份Key4当前值,以备进行下次比较
 189   5                                      }
 190   4                              }
 191   3                              keybuf5=Key5;           //把Key5当前值扫描值暂存
 192   3                              if(keybuf5!=backup5)//Key5当前值与前次值不相等,说明Key5按键有动作
 193   3                              {
 194   4                                      delay(1);               //延时去抖
 195   4                                      if(keybuf5==Key5)       //判断Key5扫描值有没有发生变化,即按键抖动       
 196   4                                      {
 197   5                                              if(backup5==1)  //Key5按键按下有效
 198   5                                              {
 199   6                                                      if(flag_gd==0)  //光照度设置允许        
 200   6                                                      {
 201   7                                                              H_GM--;         //设置上限光敏度减1
 202   7                                                              if(H_GM==-1) {H_GM=255;}        //让光敏度在0-255之间   
 203   7                                                      }
 204   6                                                      else                    //否则 调时允许
 205   6                                                      {
 206   7                                                              hour--;         //时减1
 207   7                                                              if(hour==-1) {hour=23;} //hour保持在0-23之间            
 208   7                                                      }               
 209   6                                              }
 210   5                                              backup5=keybuf5;//更新备份Key5当前值,以备进行下次比较
 211   5                                      }
 212   4                              }
 213   3                      }
 214   2                      if(flag==2)                             //下限光照度设置(调分)
 215   2                      {
 216   3                              keybuf4=Key4;           //把Key4当前值扫描值暂存
 217   3                              if(keybuf4!=backup4)//Key4当前值与前次值不相等,说明Key4按键有动作
 218   3                              {
 219   4                                      delay(1);               //延时去抖
 220   4                                      if(keybuf4==Key4)       //判断Key4扫描值有没有发生变化,即按键抖动       
 221   4                                      {
 222   5                                              if(backup4==1)  //Key4按键按下有效
 223   5                                              {
 224   6                                                      if(flag_gd==0)  //光照度设置允许        
 225   6                                                      {
 226   7                                                              L_GM++;         //设置下限光敏度加1
 227   7                                                              if(L_GM==256) {L_GM=0;} //让光敏度在0-255之间   
 228   7                                                      }
 229   6                                                      else                    //否则 调分允许
 230   6                                                      {
 231   7                                                              min++;          //分加1
 232   7                                                              if(min==60) {min=0;}    //min保持在0-59之间             
 233   7                                                      }               
 234   6                                              }
 235   5                                              backup4=keybuf4;//更新备份Key4当前值,以备进行下次比较
 236   5                                      }
 237   4                              }
 238   3                              keybuf5=Key5;           //把Key5当前值扫描值暂存
 239   3                              if(keybuf5!=backup5)//Key5当前值与前次值不相等,说明Key5按键有动作
 240   3                              {
 241   4                                      delay(1);               //延时去抖
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 5   

 242   4                                      if(keybuf5==Key5)       //判断Key5扫描值有没有发生变化,即按键抖动       
 243   4                                      {
 244   5                                              if(backup5==1)  //Key5按键按下有效
 245   5                                              {
 246   6                                                      if(flag_gd==0)  //光照度设置允许        
 247   6                                                      {
 248   7                                                              L_GM--;         //设置下限光敏度减1
 249   7                                                              if(L_GM==-1) {L_GM=255;}        //让光敏度在0-255之间   
 250   7                                                      }
 251   6                                                      else                    //否则 调分允许
 252   6                                                      {
 253   7                                                              min--;          //分减1
 254   7                                                              if(min==-1) {min=59;}   //min保持在0-59之间                     
 255   7                                                      }               
 256   6                                              }
 257   5                                              backup5=keybuf5;//更新备份Key5当前值,以备进行下次比较
 258   5                                      }
 259   4                              }
 260   3                      }
 261   2                      if(flag_gd==1&&flag==0)         //在正常显示倒计时的情况下
 262   2                      {
 263   3                              keybuf4=Key4;           //把Key4当前值扫描值暂存
 264   3                              if(keybuf4!=backup4)//Key4当前值与前次值不相等,说明Key4按键有动作
 265   3                              {
 266   4                                      delay(1);               //延时去抖
 267   4                                      if(keybuf4==Key4)       //判断Key4扫描值有没有发生变化,即按键抖动       
 268   4                                      {
 269   5                                              if(backup4==1)  //Key4按键按下有效
 270   5                                              {
 271   6                                                      Time_OFF_ON=1;  //定时开启窗帘  
 272   6                                              }
 273   5                                              backup4=keybuf4;//更新备份Key4当前值,以备进行下次比较
 274   5                                      }
 275   4                              }
 276   3                              keybuf5=Key5;           //把Key5当前值扫描值暂存
 277   3                              if(keybuf5!=backup5)//Key5当前值与前次值不相等,说明Key5按键有动作
 278   3                              {
 279   4                                      delay(1);               //延时去抖
 280   4                                      if(keybuf5==Key5)       //判断Key5扫描值有没有发生变化,即按键抖动       
 281   4                                      {
 282   5                                              if(backup5==1)  //Key5按键按下有效
 283   5                                              {
 284   6                                                      Time_OFF_ON=0;  //定时关闭窗帘  
 285   6                                              }
 286   5                                              backup5=keybuf5;//更新备份Key5当前值,以备进行下次比较
 287   5                                      }
 288   4                              }                                                                                       
 289   3                      }
 290   2              }
 291   1      }
 292          
 293          void disp1()            //光照强度显示
 294          {
 295   1              SMG_XS=table[adval/100];                //ADC输出百位显示               
 296   1              q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 297   1              delay(t);                                               //延时
 298   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 299   1      
 300   1              SMG_XS=table[adval%100/10];             //ADC输出十位显示
 301   1              q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 302   1              delay(t);                                               //延时
 303   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 6   

 304   1      
 305   1              SMG_XS=table[adval%10];                 //ADC输出个位显示
 306   1              q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 307   1              delay(t);                                               //延时
 308   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 309   1      }
 310          
 311          void disp2()            //上限光照度设置状态
 312          {
 313   1              SMG_XS=0x89;                                    //显示"H"
 314   1              q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //千位允许显示
 315   1              delay(t);                                               //延时
 316   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 317   1      
 318   1              SMG_XS=table[H_GM/100];                 //显示设置光照度百位
 319   1              q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 320   1              delay(t);                                               //延时
 321   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 322   1      
 323   1              SMG_XS=table[H_GM%100/10];              //显示设置光照度十位
 324   1              q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 325   1              delay(t);                                               //延时
 326   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 327   1      
 328   1              SMG_XS=table[H_GM%10];                  //显示设置光照度个位
 329   1              q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 330   1              delay(t);                                               //延时
 331   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐  
 332   1      }
 333          
 334          void disp3()            //下限光照度设置状态
 335          {
 336   1              SMG_XS=0xc7;                                    //显示"L"
 337   1              q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //千位允许显示
 338   1              delay(t);                                               //延时
 339   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 340   1      
 341   1              SMG_XS=table[L_GM/100];                 //显示设置光照度百位
 342   1              q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 343   1              delay(t);                                               //延时
 344   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 345   1      
 346   1              SMG_XS=table[L_GM%100/10];              //显示设置光照度十位
 347   1              q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 348   1              delay(t);                                               //延时
 349   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 350   1      
 351   1              SMG_XS=table[L_GM%10];                  //显示设置光照度个位
 352   1              q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 353   1              delay(t);                                               //延时
 354   1              q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐  
 355   1      }
 356          
 357          void disp4()    //调时显示
 358          {
 359   1              j++;                                            //j加1          
 360   1              while(j==150) {j=0;}            //j为40时,j清0
 361   1              if(j<75)                                        //j小于20  时,分 都显示                 
 362   1              {
 363   2                      SMG_XS=table[hour/10];                  //显示小时十位
 364   2                      q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //千位允许显示
 365   2                      delay(t);                                               //延时
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 7   

 366   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 367   2              
 368   2                      SMG_XS=table[hour%10]&0x7f;     //显示小时个位,带小数点
 369   2                      q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 370   2                      delay(t);                                               //延时
 371   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 372   2              
 373   2                      SMG_XS=table[min/10];                   //显示分十位
 374   2                      q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 375   2                      delay(t);                                               //延时
 376   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 377   2              
 378   2                      SMG_XS=table[min%10]&0x7f;              //显示分个位,带小数点
 379   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 380   2                      delay(t);                                               //延时
 381   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 382   2              }
 383   1              else            //否则20<j<40   时不显示,分显示 
 384   1              {
 385   2                      SMG_XS=table[hour/10];                  //显示小时十位
 386   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //不显示
 387   2                      delay(t);                                               //延时
 388   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 389   2              
 390   2                      SMG_XS=table[hour%10]&0x7f;     //显示小时个位,带小数点
 391   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //不显示
 392   2                      delay(t);                                               //延时
 393   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 394   2              
 395   2                      SMG_XS=table[min/10];                   //显示分十位
 396   2                      q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 397   2                      delay(t);                                               //延时
 398   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 399   2              
 400   2                      SMG_XS=table[min%10]&0x7f;              //显示分个位,带小数点
 401   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 402   2                      delay(t);                                               //延时
 403   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐          
 404   2              }               
 405   1      }
 406          
 407          void disp5()    //调分显示
 408          {
 409   1              j++;                                            //j加1          
 410   1              while(j==150) {j=0;}            //j为40时,j清0
 411   1              if(j<75)                                        //j小于20  时,分 都显示                 
 412   1              {
 413   2                      SMG_XS=table[hour/10];                  //显示小时十位
 414   2                      q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //千位允许显示
 415   2                      delay(t);                                               //延时
 416   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 417   2              
 418   2                      SMG_XS=table[hour%10]&0x7f;     //显示小时个位,带小数点
 419   2                      q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 420   2                      delay(t);                                               //延时
 421   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 422   2              
 423   2                      SMG_XS=table[min/10];                   //显示分十位
 424   2                      q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 425   2                      delay(t);                                               //延时
 426   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 427   2              
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 8   

 428   2                      SMG_XS=table[min%10]&0x7f;              //显示分个位,带小数点
 429   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 430   2                      delay(t);                                               //延时
 431   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 432   2              }
 433   1              else            //否则20<j<40   时显示,分不显示 
 434   1              {
 435   2                      SMG_XS=table[hour/10];                  //显示小时十位
 436   2                      q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //不显示
 437   2                      delay(t);                                               //延时
 438   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 439   2              
 440   2                      SMG_XS=table[hour%10]&0x7f;     //显示小时个位,带小数点
 441   2                      q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //不显示
 442   2                      delay(t);                                               //延时
 443   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 444   2              
 445   2                      SMG_XS=table[min/10];                   //显示分十位
 446   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //不显示
 447   2                      delay(t);                                               //延时
 448   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 449   2              
 450   2                      SMG_XS=table[min%10]&0x7f;              //显示分个位,带小数点
 451   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //不显示
 452   2                      delay(t);                                               //延时
 453   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐          
 454   2              }               
 455   1      }
 456          
 457          void disp6()            //时间显示
 458          {
 459   1              if(num>=10)             //0.5秒时间 显示带小时点
 460   1              {
 461   2                      SMG_XS=table[hour/10];                  //显示小时十位
 462   2                      q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //千位允许显示
 463   2                      delay(t);                                               //延时
 464   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 465   2                      
 466   2                      SMG_XS=table[hour%10]&0x7f;     //显示小时个位,带小数点
 467   2                      q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 468   2                      delay(t);                                               //延时
 469   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 470   2                      
 471   2                      SMG_XS=table[min/10];                   //显示分十位
 472   2                      q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 473   2                      delay(t);                                               //延时
 474   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 475   2      
 476   2                      if(Time_OFF_ON==0)                              //如果定时窗帘关闭
 477   2                      {               
 478   3                              SMG_XS=table[min%10];                   //显示分个位
 479   3                      }
 480   2                      else                                                    //否则定时窗帘打开
 481   2                      {
 482   3                              SMG_XS=table[min%10]&0x7f;;             //显示分个位,带小数点
 483   3                      }
 484   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 485   2                      delay(t);                                               //延时
 486   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 487   2              }
 488   1              else    
 489   1              {
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 9   

 490   2                      SMG_XS=table[hour/10];                  //显示小时十位
 491   2                      q_kz=0;b_kz=1;s_kz=1;g_kz=1;    //千位允许显示
 492   2                      delay(t);                                               //延时
 493   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 494   2                      
 495   2                      SMG_XS=table[hour%10];                  //显示小时个位
 496   2                      q_kz=1;b_kz=0;s_kz=1;g_kz=1;    //百位允许显示
 497   2                      delay(t);                                               //延时
 498   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 499   2                      
 500   2                      SMG_XS=table[min/10];                   //显示分十位
 501   2                      q_kz=1;b_kz=1;s_kz=0;g_kz=1;    //十位允许显示
 502   2                      delay(t);                                               //延时
 503   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐
 504   2                      
 505   2                      SMG_XS=table[min%10];                   //显示分个位
 506   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位允许显示
 507   2                      delay(t);                                               //延时
 508   2                      q_kz=1;b_kz=1;s_kz=1;g_kz=1;    //消隐          
 509   2              }       
 510   1      }
 511          
 512          void disp_cl()          //显示处理
 513          {
 514   1              if(move==0)                     //定时时间未到，处理显示函数
 515   1              {
 516   2                      if(flag==0)             //正常显示
 517   2                      {
 518   3                              if(flag_gd==0)  //光控模式下
 519   3                              {
 520   4                                      disp1();                //光照强度显示          
 521   4                              }
 522   3                              else                    //否则定时模式下
 523   3                              {
 524   4                                      disp6();        //时间显示
 525   4                                      TR0=0;          //关闭定时器0   
 526   4                              }                       
 527   3                      }
 528   2                      else if(flag==1)        //上限光照度设置显示(调时)
 529   2                      {
 530   3                              if(flag_gd==0)  //光控模式下
 531   3                              {
 532   4                                      disp2();        //上限光照度设置状态            
 533   4                              }
 534   3                              else                    //否则定时模式下
 535   3                              {
 536   4                                      disp4();        //调时显示      
 537   4                              }                       
 538   3                      }
 539   2                      else if(flag==2)        //下限光照度设置显示(调分)
 540   2                      {
 541   3                              if(flag_gd==0)  //光控模式下
 542   3                              {
 543   4                                      disp3();        //下限光照度设置状态            
 544   4                              }
 545   3                              else                    //否则定时模式下
 546   3                              {
 547   4                                      disp5();        //调分显示      
 548   4                              }
 549   3                      }
 550   2              }
 551   1              else            //定时器时间到了                
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 10  

 552   1              {
 553   2                      if(Time_OFF_ON==1)              //如果定时打开窗帘
 554   2                      {
 555   3                              OFF_ON=1;                       //窗帘打开
 556   3                              TR0=1;                          //开启定时器0
 557   3                              SMG_XS=table[1];        //数码管显示"1"
 558   3                              q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位显示
 559   3                      }       
 560   2                      else                                    //否则定时窗帘     
 561   2                      {
 562   3                              OFF_ON=0;                       //窗帘关闭
 563   3                              TR0=1;                          //开启定时器0
 564   3                              SMG_XS=table[0];        //数码管显示"0"
 565   3                              q_kz=1;b_kz=1;s_kz=1;g_kz=0;    //个位显示
 566   3                      }                       
 567   2              }
 568   1      }
 569          
 570          void GZQD()             //光照强度(根据ADC0804转换器时序编写)
 571          {
 572   1              static uint i=0;        //定义临时变量i
 573   1              CS=0;                           
 574   1              WR=0;           //启动AD转换
 575   1              delay(1);
 576   1              WR=1;
 577   1              CS=1;
 578   1              for(i=0;i<130;i++)      //AD转换需要一点时间,利用for循环处理,来延时一会，不影响显示和按键处理
 579   1              {
 580   2                      disp_cl();      //显示处理
 581   2                      Key_cl();       //按键处理
 582   2              } 
 583   1              P1=0xff;                //读取AD转换值前,先把P1口置1            
 584   1              CS=0;
 585   1              RD=0;                   //AD读使能
 586   1              delay(1);               
 587   1              adval=P1;               //把AD转换好的值,赋给 adval
 588   1              RD=1;
 589   1              CS=1;                   //置1后,为下次AD转换做准备
 590   1              delay(1);
 591   1      }               
 592          
 593          void GM_cl()            //光照度处理
 594          {
 595   1              if(ms==1)               //自动模式下
 596   1              {                                                                                
 597   2                      if(adval<L_GM)          {OFF_ON=1;TR0=1;}       //实际光照强度小于设定下限光照度值时,打开窗帘(启动定时器0)
 598   2                      else if(adval>H_GM)     {OFF_ON=0;TR0=1;}       //反之光照强度大于设定上限光照度值,关闭窗帘(启动定时器0)
 599   2                      else                            {TR0=0;IA=0;IB=0;}      //光照强度在正常范围内,窗帘不动(关闭定时器0)
 600   2              }
 601   1      }
 602          
 603          
 604          void main()                             //主函数入口
 605          {
 606   1              Time_init();            //定时器初始化
 607   1              Time_OFF_ON=0;          //默认定时关闭窗帘
 608   1              while(1)                        //主循环
 609   1              {       
 610   2                      Key_cl();               //按键处理
 611   2                      if(ms==1)               //自动模式下
 612   2                      {
 613   3                              if(flag_gd==0)  //光控模式
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 11  

 614   3                              {       
 615   4                                      TR1=0;          //关闭定时器1
 616   4                                      GZQD();         //光照强度
 617   4                                      GM_cl();        //光照度处理
 618   4                              }
 619   3                              else                    //否则定时器模式
 620   3                              {
 621   4                                      TR1=1;          //开启定时器1   
 622   4                              }
 623   3                              disp_cl();              //显示处理      
 624   3                      }
 625   2                      else                            //否则手动模式下 
 626   2                      {
 627   3                              TR1=0;                  //关闭定时器1   
 628   3                      }                               
 629   2              }
 630   1      }
 631          
 632          void Time0() interrupt 1        //定时器0中断服务函数
 633          {                                                       //利用定时器0产生PWM占空比,占空比小,可以降低直流电机转速
 634   1              static uchar a=1;               //定义临时变量a=1
 635   1              TH0=0xf8;                               //定时2ms
 636   1              TL0=0xcc;
 637   1              if(OFF_ON==1)   //如果窗帘需要打开
 638   1              {
 639   2                      if(Up==1)       //上限限位开关为1(表示窗帘没有到上限位置)
 640   2                      {
 641   3                              if(a<=1) {IA=1; IB=0;}          //电机正转
 642   3                              else     {IA=0; IB=0;}
 643   3                      }
 644   2                      else            //否则到上限位置
 645   2                      {
 646   3                              IA=0; IB=0;                                     //电机停止              
 647   3                      } 
 648   2              }
 649   1              else                    //否则窗帘需要关闭
 650   1              {
 651   2                      if(Down==1)     //下限限位开关为1(表示窗帘没有到下限位置)
 652   2                      {
 653   3                              if(a<=1) {IA=0; IB=1;}          //电机反转
 654   3                              else     {IA=0; IB=0;}          
 655   3                      }
 656   2                      else            //否则到下限位置
 657   2                      {
 658   3                              IA=0; IB=0;                                     //电机停止      
 659   3                      }
 660   2              }
 661   1              a++;    //a加1
 662   1              while(a==18) {a=1;}     //a保持在1到27之间(a=1,电机转，1<a<18电机不转,这样的PWM比较小,达到转速慢)
 663   1      }
 664          
 665          void Time1() interrupt 3        //定时器1中断服务函数(产生定时时间)
 666          {
 667   1              TH1=0x4c;               //50ms
 668   1              TL1=0x00;
 669   1              num++;                  //num加1                
 670   1              while(num==20)  //1秒时间到
 671   1              {
 672   2                      num=0;          //秒清0
 673   2                      sec--;          //秒减1
 674   2                      while(sec==-1)  //当秒等于-1
 675   2                      {
C51 COMPILER V9.03   ZNCL                                                                  09/10/2015 17:41:08 PAGE 12  

 676   3                              sec=59;         //秒置59
 677   3                              min--;          //分减1
 678   3                              while(min==-1)  //当分等于-1
 679   3                              {
 680   4                                      min=59;         //分置59
 681   4                                      hour--;         //小时减1
 682   4                              }
 683   3                      }
 684   2                      while(hour==0&&min==0&&sec==0)  //定时时间到
 685   2                      {
 686   3                              hour=12;min=0;sec=0;    //时间初始化恢复 12.00.00
 687   3                              move=1;         //定时时间到    
 688   3                      }
 689   2              }
 690   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2373    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     15    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
